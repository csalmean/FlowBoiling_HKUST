# -*- coding: utf-8 -*-
"""
Created on Wed Nov 17 00:50:28 2021

RTD calibration calculator
Simply takes the files generated by the control software on calibration mode, and outputs summary file containing TCRs of each RTD.

@author: ccsalmean
"""
import os
import pandas as pd
import numpy as np
from numpy import polyfit
from scipy.odr import *

pd.options.mode.chained_assignment = None  # default='warn'

# Takes the TC value, and all resistance values.
# Calculates resistance of each heater at each temperature and filters
# Highlights silly values (i.e. lost connection)
# Generates slope, intercept, rsq, p-value and st error of each.

# Operates on 'Data' folder in same path as itself.
root=(os.path.abspath(os.curdir)).split('Analysis')[0]
folder=os.path.join(root,'Data')

projects = [f.path for f in os.scandir(folder) if f.is_dir()]

TC_error=0.1 # abs error in degC

# Define a function (quadratic in our case) to fit the data with.
def lin_func(p, x):
     m, c = p
     return m*x + c

for project in projects:
    chip_name=project.split('_')[0]
    # Only operates on files which have 'cal' in their names
    if 'cal' in project:
        print('\n*********************************************\n',project)
        # We will just attempt to overwrite them all anyway, if they do exist.
        filelist=[file for file in os.listdir(project) if (file.endswith('.csv'
                        )) and ('USS' in file)]
            
        RTDdata=pd.DataFrame()
        for file in filelist:
            RTDdata=pd.concat([RTDdata,pd.read_csv(os.path.join(project,file))]).apply(pd.to_numeric, errors='coerce').sort_values('TC1.T')
                
        chip_name = project.split('\\')[-1]
        file_name=''.join([chip_name,'_summary'+'.csv'])
        complete_name=os.path.join(project,file_name)
    
        # isolate the column containing temperature information
        ys=list(RTDdata['TC1.T'])
        y = np.array(ys)
        y_err = np.full(np.shape(y),TC_error) # degrees error in thermocouple measurement
    
        # Isolate the columns which contain resistance measurements
        Rcols=[col for col in RTDdata.columns if (col[-1] == 'R' and 'RTD' not in col)]
        Rdata=RTDdata[Rcols]
        
        results=pd.DataFrame()
        results['Var']=pd.Series(['m','c','U_m [%]','U_c [%]' ])
        
        summarystring=''
        
        for col in Rdata.columns:
            print('_____________________________\n')
            x=np.array(Rdata[col])
            x_err = np.array([0.000025*i for i in x])

            # find slope in best and worst case scenarios
            # 1: unaltered

            # Create a model for fitting.
            lin_model = Model(lin_func)
            
            # Create a RealData object using our initiated data from above.
            data = RealData(x, y, sx=x_err, sy=y_err)
            
            # Set up ODR with the model and data.
            odr = ODR(data, lin_model, beta0=[0., 1.])
            
            # Run the regression.
            out = odr.run()
            
            # parameters and uncertainties 
            params_a= out.beta
            unca=np.sqrt(np.diag(out.cov_beta * out.res_var))
            # print(f'Unaltered: {params_a},\nUnc: {unca}')
            
            # Now alter in one direction:
            new_x=x.copy()
            new_x[x<np.mean(x)]-=x_err[x<np.mean(x)]
            new_x[x>np.mean(x)]+=x_err[x>np.mean(x)]
            
            new_y=y.copy()
            new_y[y<np.mean(y)]+=TC_error
            new_y[y>np.mean(y)]-=TC_error
            
            params_b = polyfit(new_x,new_y,1)
            # print(f'Low: {params_b}')
            
            # Now alter in other direction:
            new_x=x.copy()
            new_x[x<np.mean(x)]+=x_err[x<np.mean(x)]
            new_x[x>np.mean(x)]-=x_err[x>np.mean(x)]
            
            new_y=y.copy()
            new_y[y<np.mean(y)]-=TC_error
            new_y[y>np.mean(y)]+TC_error
            
            params_c = polyfit(new_x,new_y,1)
            
            # print(f'High: {params_c}')
            
            m_diff=100*(params_c[0]-params_b[0])/(2*params_a[0])
            c_diff=100*(params_c[1]-params_b[1])/(2*params_a[1])
            
            print(f'\n{col} Summary:\nm: {np.round(params_a[0],4)} ',u"\u00B1",
                  f' {np.round(m_diff,4)} %,\nc: {np.round(params_a[1],4)} ',
                  u"\u00B1",f' {np.round(c_diff,4)} %')
            
            results[col]=pd.Series([params_a[0],params_a[1],m_diff,c_diff])
            
            heater=col.split('.')[0]
            summarystring+=(heater+'_b:'+str(params_a[0])+','
                            +heater+'_c:'+str(params_a[1])+',')
            
        results['Average']=np.mean(results[Rcols],axis=1)
        
        df_new = pd.DataFrame({'Average':[summarystring]})

        results = (pd.concat([results, df_new], ignore_index=True)
                  .reindex(columns=results.columns)
                  .fillna(0, downcast='infer'))
        

        file_name=''.join([chip_name,'_summary'+'.csv'])
        complete_name=os.path.join(project,file_name)

        try:
            results.to_csv(complete_name, mode = 'w')
            print(f'{file_name} written.')
        except:
            print(f'{file_name} failed to write...')
